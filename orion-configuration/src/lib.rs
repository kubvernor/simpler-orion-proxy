#![allow(clippy::wildcard_imports)]
// SPDX-FileCopyrightText: Â© 2025 Huawei Cloud Computing Technologies Co., Ltd
// SPDX-License-Identifier: Apache-2.0
//
// Copyright 2025 Huawei Cloud Computing Technologies Co., Ltd
//
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//

use orion_error::Error;
pub(crate) type BoxedError = Box<dyn std::error::Error + Send + Sync>;

#[allow(clippy::wildcard_imports, clippy::too_many_lines)]
pub mod config;
pub mod options;

pub type Result<T> = std::result::Result<T, Error>;

pub trait VerifySingleIter: Iterator {
    fn verify_single(self) -> ::std::result::Result<Self::Item, BoxedError>;
}

impl<I> VerifySingleIter for I
where
    I: Iterator,
{
    fn verify_single(mut self) -> ::std::result::Result<Self::Item, BoxedError> {
        match (self.next(), self.next()) {
            (Some(first), None) => Ok(first),
            (None, _) => Err("Iterator is empty".into()),
            (Some(_), Some(_)) => Err("Iterator contains more than one element".into()),
        }
    }
}

#[cfg(feature = "envoy-conversions")]
#[cfg(test)]
mod tests {
    #[test]
    fn protobuf_decode_any_conn_manager_go_control() {
        use orion_data_plane_api::envoy_data_plane_api::{
            envoy::{
                config::core::v3::{
                    ApiConfigSource, ApiVersion, ConfigSource, GrpcService,
                    api_config_source::ApiType::Grpc,
                    config_source::ConfigSourceSpecifier,
                    grpc_service::{EnvoyGrpc, TargetSpecifier},
                },
                extensions::filters::network::http_connection_manager::v3::{
                    HttpConnectionManager as EnvoyHttpConnectionManager, HttpFilter, Rds,
                    http_connection_manager::RouteSpecifier, http_filter::ConfigType,
                },
            },
            google::protobuf::Any,
            prost::Message,
        };

        // This is generated by go-control plane for the default listener resource
        const PAYLOAD: &[u8] = b"\x12\x04http*S\n\x0bhttp-router\"D\nBtype.googleapis.com/envoy.extensions.filters.http.router.v3.Router\x1a*\n\x1b0\x02\x12\x17\x08\x02\"\x0f\n\r\n\x0bxds_cluster8\x01@\x02\x12\x0blocal_route";
        let expected_conn_manager = EnvoyHttpConnectionManager {
            stat_prefix: "http".to_owned(),
            http_filters: vec![HttpFilter {
                name: "http-router".to_owned(),
                config_type: Some(ConfigType::TypedConfig(Any {
                    type_url: "type.googleapis.com/envoy.extensions.filters.http.router.v3.Router".to_owned(),
                    value: vec![],
                })),
                ..Default::default()
            }],
            route_specifier: Some(RouteSpecifier::Rds(Rds {
                config_source: Some(ConfigSource {
                    resource_api_version: ApiVersion::V3.into(),
                    config_source_specifier: Some(ConfigSourceSpecifier::ApiConfigSource(ApiConfigSource {
                        api_type: Grpc.into(),
                        transport_api_version: ApiVersion::V3.into(),
                        grpc_services: vec![GrpcService {
                            target_specifier: Some(TargetSpecifier::EnvoyGrpc(EnvoyGrpc {
                                cluster_name: "xds_cluster".into(),
                                ..Default::default()
                            })),
                            ..Default::default()
                        }],
                        set_node_on_first_message_only: true,
                        ..Default::default()
                    })),
                    ..Default::default()
                }),
                route_config_name: "local_route".to_owned(),
            })),
            ..Default::default()
        };
        // This one will fail to decode without checking equality
        let m = EnvoyHttpConnectionManager::decode(PAYLOAD).unwrap();
        assert_eq!(m, expected_conn_manager);
    }
}
